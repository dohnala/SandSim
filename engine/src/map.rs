extern crate console_error_panic_hook;

use wasm_bindgen::prelude::*;
use crate::rand::Random;
use crate::map_generator::MapGenerator;
use crate::math::{Vec2, path, sign};
use crate::pixel::{PixelDisplayInfo, Pixel, EmptyPixelState, StaticPixelState, SolidPixelState, PixelInfo, Updatable, Movable, ToPixel};
use crate::element::{Element, ElementType};

// Represents a square chunk in the map which can be processed independently
#[wasm_bindgen]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Chunk {
    x: i32,
    y: i32,
    active: bool,
    active_next_tick: bool,
}

#[wasm_bindgen]
impl Chunk {
    pub fn x(&self) -> i32 {
        self.x
    }

    pub fn y(&self) -> i32 {
        self.y
    }

    pub fn active(&self) -> bool {
        self.active
    }

    pub fn active_next_tick(&self) -> bool {
        self.active_next_tick
    }
}

impl Chunk {
    fn new(pos: Vec2<i32>) -> Chunk {
        Chunk { x: pos.x, y:pos.y, active: true, active_next_tick: true }
    }

    pub fn pos(&self) -> Vec2<i32> {
        Vec2::new(self.x, self.y)
    }
}

// Represents a map configuration
#[wasm_bindgen]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MapConfig {
    pub size: i32,
    pub gravity: f32,
    pub max_velocity: f32,
    pub use_chunks: bool,
    pub chunk_size: i32,
    pub seed: u16,
}

#[wasm_bindgen]
impl MapConfig {
    pub fn new(size: i32, gravity: f32, max_velocity: f32,
               use_chunks: bool, chunk_size: i32, seed: u16) -> MapConfig {
        MapConfig {
            size,
            gravity,
            max_velocity,
            use_chunks,
            chunk_size,
            seed,
        }
    }
}

// Represents a map composed of pixels
#[wasm_bindgen]
pub struct Map {
    // Map configuration
    config: MapConfig,
    // Pixels and their states
    pixels: Vec<Pixel>,
    // Pixel information used to display the map
    display: Vec<PixelDisplayInfo>,
    // Exclusive chunks used to process pixels
    chunks: Vec<Chunk>,
    // The dimension of chunk vector
    chunk_dim: i32,
    // Used to determine which pixels were updated during a tick
    clock: u8,
    // Pseudo random generator
    random: Random,
    // How much ticks pixel does not have to move and still be updated
    not_moved_threshold: u8,
}

#[wasm_bindgen]
impl Map {
    // Create a new empty map
    pub fn new_empty(config: MapConfig) -> Map {
        Map::new(config, MapGenerator::EMPTY)
    }

    // Create a new cave map
    pub fn new_cave(config: MapConfig) -> Map {
        Map::new(config, MapGenerator::CAVE)
    }

    // Creates a new map generated by given generator
    pub fn new(config: MapConfig, generator: MapGenerator) -> Map {
        console_error_panic_hook::set_once();

        let mut random = Random::new(config.seed);

        let elements = generator.generate_map(&config);

        let pixels: Vec<Pixel> = (&elements)
            .into_iter()
            .map(|element| { Map::create_pixel(*element, &mut random) })
            .collect();

        let display = (&pixels)
            .into_iter()
            .map(|pixel| { PixelDisplayInfo::new(pixel) })
            .collect();

        let chunks = if config.use_chunks {
            Map::generate_chunks(config.size, config.chunk_size)
        } else { vec![] };

        let chunk_dim = if config.use_chunks {
            config.size / config.chunk_size
        } else {0};

        let not_moved_threshold = (1f32 / config.gravity).clamp(1f32, 10f32) as u8;

        Map {
            config,
            pixels,
            display,
            chunks,
            chunk_dim,
            clock: 0,
            random,
            not_moved_threshold,
        }
    }

    // Inserts a new pixels of given element in radius from x,y
    pub fn insert(&mut self, x: i32, y: i32, element: Element, radius: i32) {
        for i in -radius..=radius {
            for j in -radius..=radius {
                if i*i + j*j <= radius*radius {
                    self.insert_pixel(Vec2::new(x, y) + Vec2::new(i, j), element);
                }
            }
        }
    }

    // Clears the map so its empty
    pub fn clear(&mut self) {
        self.clock = 0;

        for x in 0..self.config.size {
            for y in 0..self.config.size {
                let index = self.pixel_index(Vec2::new(x, y));

                let pixel = Map::create_pixel(Element::Empty, &mut self.random);
                self.pixels[index] = pixel;
                self.display[index] = PixelDisplayInfo::new(&pixel)
            }
        }
    }

    // Simulates a tick and return number of processed pixels
    pub fn tick(&mut self) -> u32 {
        self.reset_chunks();
        self.clock = self.clock.wrapping_add(1);

        let processed_pixels: u32 = if self.config.use_chunks {
            self.process_chunks()
        } else {
            self.process_pixels(Vec2::new(0, 0),
                                Vec2::new(self.config.size, self.config.size))
        };

        return processed_pixels;
    }

    // Returns a config for this map
    pub fn config(&self) -> MapConfig {
        self.config
    }

    // Returns pointer to the pixel display data
    pub fn display(&self) -> *const PixelDisplayInfo {
        self.display.as_ptr()
    }

    // Returns information about pixel on given x,y
    pub fn pixel_info(&self, x: i32, y: i32) -> Option<PixelInfo> {
        let pos = Vec2::new(x, y);

        if self.out_of_bounds(pos) {
            return None;
        }

        return Some(PixelInfo::new(&self.pixels[self.pixel_index(pos)]));
    }

    // Returns number of chunks
    pub fn chunks_count(&self) -> usize {
        self.chunks.len()
    }

    // Returns ith chunk
    pub fn chunk(&self, i: usize) -> Chunk {
        self.chunks[i]
    }
}

impl Map {
    // Returns index in pixels vector for given position
    fn pixel_index(&self, pos: Vec2<i32>) -> usize {
        (pos.x + (pos.y * self.config.size)) as usize
    }

    // Returns index in chunks vector for given position
    fn chunk_index(&self, pos: Vec2<i32>) -> usize {
        (pos.x + (pos.y * self.chunk_dim)) as usize
    }

    // Returns pixel for given position
    pub fn pixel(&mut self, x: i32, y: i32) -> Pixel {
        let pos = Vec2::new(x, y);

        if self.out_of_bounds(pos) {
            return Map::create_pixel(Element::Wall, &mut self.random);
        }

        return self.pixels[self.pixel_index(pos)];
    }

    // Updates given pixel
    fn update_pixel(&mut self, x: i32, y: i32) -> bool {
        let pixel= &mut self.pixel(x, y);

        match pixel {
            Pixel::Empty(_) => false,
            Pixel::Static(_) => false,
            Pixel::Solid(state) => {
                if self.can_update(state) {
                    pixel.update(&mut MapApi::new(Vec2::new(x, y), self));
                    true
                } else {
                    false
                }
            }
        }
    }

    // Returns true if given pixel can be updated
    fn can_update<T: Updatable>(&self, pixel: &mut T) -> bool {
        let allow = pixel.clock() != self.clock;

        if allow {
            pixel.set_clock(self.clock);
        }

        return allow;
    }

    // Inserts a new pixel of given element at given position
    fn insert_pixel(&mut self, pos: Vec2<i32>, element: Element) {
        if self.out_of_bounds(pos) {
            return;
        }

        let allow_insert = match self.pixel(pos.x, pos.y) {
            Pixel::Empty(_) => true,
            _ => match Element::element_type(element) {
                ElementType::Empty(_) => true,
                _ => false,
            }
        };

        if allow_insert {
            let index = self.pixel_index(pos);
            let pixel = Map::create_pixel(element, &mut self.random);

            self.pixels[index] = pixel;
            self.display[index] = PixelDisplayInfo::new(&pixel);

            self.activate_surrounding_pixels(pos);
        }
    }

    // Create new pixel from given element
    fn create_pixel(element: Element, random: &mut Random) -> Pixel {
        match Element::element_type(element) {
            ElementType::Empty(properties) => Pixel::Empty(
                EmptyPixelState::new(element, properties)),
            ElementType::Static(properties) => Pixel::Static(
                StaticPixelState::new(element, properties)),
            ElementType::Solid(properties) => {
                let velocity = match random.rand(&[0.5f32, 0.5f32]) {
                    0 => Vec2::new(-0.02f32, 0f32),
                    _ => Vec2::new(0.02f32, 0f32),
                };

                Pixel::Solid(SolidPixelState::new(element, properties, velocity))
            }
        }
    }

    // Generates chunks of given size for map of given size and return them
    fn generate_chunks(map_size: i32, chunk_size: i32) -> Vec<Chunk> {
        return (0..map_size).step_by(chunk_size as usize)
            .into_iter()
            .flat_map(|y| {
                return (0..map_size).step_by(chunk_size as usize)
                    .into_iter()
                    .map(move |x| {
                        Chunk::new(Vec2::new(x, y))
                    })
            })
            .collect();
    }

    // Resets chunks for next tick
    fn reset_chunks(&mut self) {
        for mut chunk in self.chunks.iter_mut() {
            chunk.active = chunk.active_next_tick;
            chunk.active_next_tick = false;
        }
    }

    // Marks a chunk for given pixel position active for next tick
    fn set_chunk_active_next_tick(&mut self, pixel_pos: Vec2<i32>) {
        if self.config.use_chunks {
            let index = self.chunk_index(pixel_pos / self.config.chunk_size);

            match self.chunks.get_mut(index) {
                Some(chunk) => {
                    chunk.active_next_tick = true
                }
                None => {}
            }
        }
    }

    // Process all active chunks and pixels they contain
    fn process_chunks(&mut self) -> u32 {
        let mut pixels = 0;

        // Process chunks from bottom
        for chunk_y in (0..self.chunk_dim).rev() {
            for chunk_x in 0..self.chunk_dim {
                // process chunks from different side each tick
                let chunk_scan_x = if self.clock % 2 == 0 {
                    self.chunk_dim - (1 + chunk_x)
                } else {
                    chunk_x
                };

                let chunk = self.chunk(self.chunk_index(
                    Vec2::new(chunk_scan_x, chunk_y)));

                if chunk.active {
                    pixels += self.process_pixels(
                        chunk.pos(),
                        chunk.pos() + Vec2::new(
                            self.config.chunk_size, self.config.chunk_size));
                }
            }
        }

        return pixels;
    }

    // Process pixels within given rectangle area
    fn process_pixels(&mut self, from: Vec2<i32>, to: Vec2<i32>) -> u32 {
        let mut pixels = 0;

        // Process pixels from bottom
        for y in (from.y..to.y).rev() {
            for x in from.x..to.x {
                // process pixels from different side each tick
                let scan_x = if self.clock % 2 == 0 {
                    from.x + to.x - (1 + x)
                } else {
                    x
                };

                pixels += self.update_pixel(scan_x, y) as u32;
            }
        }

        return pixels;
    }

    // Activates pixel on given position by activating corresponding chunk
    fn activate_pixel(&mut self, pos: Vec2<i32>) {
        if self.out_of_bounds(pos) {
            return;
        }

        self.set_chunk_active_next_tick(pos)
    }

    // Activates pixel on given position and all its surrounding pixels
    // by activating corresponding chunks
    fn activate_surrounding_pixels(&mut self, pos: Vec2<i32>) {
        for dir_x in -1..=1 {
            for dir_y in -1..=1 {
                self.activate_pixel(pos + Vec2::new(dir_x, dir_y));
            }
        }
    }

    // Return true if given position is out of bounds of the map
    fn out_of_bounds(&self, pos: Vec2<i32>) -> bool {
        return pos.x < 0 || pos.x > self.config.size - 1 || pos.y < 0 || pos.y > self.config.size - 1
    }
}

// Map API which pixels can use to define its behavior
pub struct MapApi<'a> {
    pos: Vec2<i32>,
    map: &'a mut Map,
}

impl<'a> MapApi<'a> {
    // Creates a new Map api for pixel at x, y
    pub fn new(pos: Vec2<i32>, map: &'a mut Map) -> MapApi {
        MapApi {
            pos,
            map,
        }
    }

    // Returns random generator
    pub fn random(&mut self) -> &mut Random {
        &mut self.map.random
    }

    // Returns gravity
    pub fn gravity(&self) -> Vec2<f32> {
        return Vec2::new(0f32, self.map.config.gravity);
    }

    // Adds velocity to given pixel
    pub fn add_velocity<T: Movable>(&mut self, pixel: &mut T, velocity: Vec2<f32>) {
        self.set_velocity(pixel, pixel.velocity() + velocity);
    }

    // Sets velocity to given pixel
    pub fn set_velocity<T: Movable>(&mut self, pixel: &mut T, velocity: Vec2<f32>) {
        pixel.set_velocity(Vec2::new(
            velocity.x.clamp(-self.map.config.max_velocity, self.map.config.max_velocity),
            velocity.y.clamp(-self.map.config.max_velocity, self.map.config.max_velocity),
        ));
    }

    // Sets falling flag to given pixel
    pub fn set_falling<T: Movable>(&mut self, pixel: &mut T, falling: bool) {
        pixel.set_falling(falling);
    }

    // Returns a pixel in direction (dx, dy) relative to current pixel
    pub fn pixel(&mut self, dir: Vec2<i32>) -> Pixel {
        let new_pos = self.pos + dir;
        self.map.pixel(new_pos.x, new_pos.y)
    }

    // Sets a pixel at to a direction (dx, dy) relative to current pixel
    pub fn set_pixel(&mut self, dir: Vec2<i32>, pixel: &Pixel) {
        let new_pos = self.pos + dir;

        if self.map.out_of_bounds(new_pos) {
            return;
        }

        let index = self.map.pixel_index(new_pos);

        self.map.pixels[index] = *pixel;
        self.map.display[index] = PixelDisplayInfo::new(pixel);
    }

    // Activates pixel on given relative position, so it will be processed next tick
    pub fn activate_pixel(&mut self, dir: Vec2<i32>) {
        self.map.activate_pixel(self.pos + dir)
    }

    // Activates pixel on given relative position and all its surrounding pixels
    // so they will be processed next tick
    pub fn activate_surrounding_pixels(&mut self, dir: Vec2<i32>) {
        self.map.activate_surrounding_pixels(self.pos + dir);
    }

    // Returns a direction of pixel's normalized velocity
    pub fn direction<T: Movable>(&self, pixel: &T) -> Vec2<i32> {
        pixel.velocity().direction()
    }

    // Activates the pixel when moved with respect to given not moved threshold
    // so even when a pixel does not move with less ticks then this threshold, we will
    // still update it
    pub fn activate_when_moved<T: Movable + ToPixel>(&mut self, pixel: &mut T) {
        if pixel.not_moved_count() >= self.map.not_moved_threshold {
            pixel.set_not_moved_count(self.map.not_moved_threshold);
            self.set_pixel(Vec2::new(0, 0), &pixel.to_pixel());
        }

        if pixel.falling() || pixel.not_moved_count() < self.map.not_moved_threshold {
            self.activate_pixel(Vec2::new(0, 0));
        }
    }

    // Displaces a pixel on given position according to its inertia
    pub fn displace(&mut self, pos: Vec2<i32>) {
        let pixel = self.pixel(pos);

        match pixel {
            Pixel::Empty(_) => {},
            Pixel::Static(_) => {},
            Pixel::Solid(mut state) => {
                let displace = match self.random().rand(
                    &[state.properties.inertia, 1f32 - state.properties.inertia]) {
                    0 => false,
                    _ => true,
                };

                if displace {
                    self.set_falling(&mut state, true);
                    self.set_pixel(pos, &state.to_pixel());
                }
            },
        }
    }

    // Computes a path in the map of the pixel according to its velocity and pass that context
    // to given function which should decide what to do by providing the result
    pub fn move_by_velocity<T: Movable + ToPixel>(&mut self,
                                                  pixel: &mut T,
                                                  move_f: fn(&mut T,
                                                             &mut Pixel,
                                                             &mut MapApi,
                                                             &MoveContext) -> MoveResult) {

        let velocity_sign = Vec2::new(
            sign(pixel.velocity().x) as i32,
            sign(pixel.velocity().y) as i32);

        let velocity_size = Vec2::new(
            pixel.velocity().x.abs(),
            pixel.velocity().y.abs());

        let pos_x = if velocity_size.x < 1f32 {
            let velocity_threshold_x = pixel.velocity_threshold().x + velocity_size.x;
            let velocity_x = velocity_threshold_x as i32;
            if velocity_x > 0 {
                pixel.set_velocity_threshold(Vec2::new(0f32, pixel.velocity_threshold().y));
            } else {
                pixel.set_velocity_threshold(Vec2::new(
                    velocity_threshold_x,
                    pixel.velocity_threshold().y));
            }
            velocity_x * velocity_sign.x
        } else {
            pixel.set_velocity_threshold(Vec2::new(0f32, pixel.velocity_threshold().y));
            pixel.velocity().x as i32
        };

        let pos_y = if velocity_size.y < 1f32 {
            let velocity_threshold_y = pixel.velocity_threshold().y + velocity_size.y;
            let velocity_y = velocity_threshold_y as i32;
            if velocity_y > 0 {
                pixel.set_velocity_threshold(Vec2::new(pixel.velocity_threshold().x, 0f32));
            } else {
                pixel.set_velocity_threshold(Vec2::new(
                    pixel.velocity_threshold().x,
                    velocity_threshold_y));
            }
            velocity_y * velocity_sign.y
        } else {
            pixel.set_velocity_threshold(Vec2::new(pixel.velocity_threshold().x, 0f32));
            pixel.velocity().y as i32
        };

        let target_pos = Vec2::new(pos_x, pos_y);

        // Keep track of last valid position during the movement
        let mut last_valid_pos = Vec2::new(0, 0);

        for (i, pos) in path(
            Vec2::new(0, 0), target_pos).enumerate() {

            let mut contact = self.pixel(pos);

            let result = move_f(pixel, &mut contact, self, &mut MoveContext::new(
                pos,
                i == 0,
                pos == target_pos,
                last_valid_pos,
                0));

            match result {
                // Continue moving along the path and update last valid position
                MoveResult::CONTINUE => {
                    last_valid_pos = pos;
                    continue
                },
                // Finalize the movement by swapping the pixels and activating them
                MoveResult::MOVE {pos: move_pos} => {
                    if self.moved(move_pos) {
                        // Reset not moved count flag
                        pixel.set_not_moved_count(0);
                        // Swap pixels
                        self.swap(&pixel.to_pixel(), move_pos);
                        return;
                    } else {
                        break;
                    }
                },
                MoveResult::STOP => {
                    if self.moved(last_valid_pos) {
                        // Reset not moved count flag
                        pixel.set_not_moved_count(0);
                        // Swap pixels
                        self.swap(&pixel.to_pixel(), last_valid_pos);
                        return;
                    } else {
                        break;
                    }
                }
            }
        }

        // If we did not move, increment not moved count,and update itself
        // so the changes are stored
        pixel.set_not_moved_count(pixel.not_moved_count() + 1);
        self.set_pixel(Vec2::new(0, 0), &pixel.to_pixel());
    }

    // Moves to a neighbor position using given unit direction and pass a new context
    // to given function which should do the actual movement
    //
    // This can only be called inside move function where the move context is available
    pub fn move_by_direction<T: Movable>(&mut self,
                                         pixel: &mut T,
                                         dir: Vec2<i32>,
                                         context: &MoveContext,
                                         move_f: fn(&mut T,
                                                    &mut Pixel,
                                                    &mut MapApi,
                                                    &MoveContext) -> MoveResult) -> MoveResult {
        let mut contact = self.pixel(context.last_valid_pos + dir);

        return move_f(pixel, &mut contact, self, &MoveContext::new(
            context.last_valid_pos + dir,
            false,
            true,
            context.last_valid_pos,
            context.depth + 1));
    }
}
impl<'a> MapApi<'a> {
    // Swaps given pixel with pixel on given position
    fn swap(&mut self, pixel: &Pixel, pos: Vec2<i32>) {
        // Swap the pixels and activate them
        let target_pixel = self.pixel(pos);

        self.set_pixel(Vec2::new(0, 0), &target_pixel);
        self.activate_surrounding_pixels(Vec2::new(0, 0));
        self.set_pixel(pos, pixel);
        self.activate_surrounding_pixels(pos);
    }

    fn moved(&self, pos: Vec2<i32>) -> bool {
        pos.x != 0 || pos.y != 0
    }
}

pub struct MoveContext<> {
    pub pos: Vec2<i32>,
    pub first_move: bool,
    pub last_move: bool,
    pub last_valid_pos: Vec2<i32>,
    pub depth: u8,
}

impl MoveContext {
    pub fn new(pos: Vec2<i32>,
               first_move: bool,
               last_move: bool,
               last_valid_pos: Vec2<i32>,
               depth: u8) -> MoveContext {
        MoveContext { pos, first_move, last_move, last_valid_pos, depth }
    }
}

pub enum MoveResult {
    CONTINUE,
    STOP,
    MOVE {pos: Vec2<i32>}
}