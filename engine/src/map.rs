extern crate console_error_panic_hook;

use wasm_bindgen::prelude::*;
use crate::element::Element;
use crate::rand::Random;
use crate::map_generator::MapGenerator;

// Represents a read-only pixel on the map
#[wasm_bindgen]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Pixel {
    element: Element,
    // the struct must have 4 bytes
    // empty registers so far, which can be used later
    ra: u8,
    rb: u8,
    rc: u8,
}

#[wasm_bindgen]
impl Pixel {
    // Creates a new pixel with given element
    pub fn new(element: Element) -> Pixel {
        Pixel {
            element,
            ra: 0,
            rb: 0,
            rc: 0,
        }
    }

    pub fn element(&self) -> Element {
        self.element
    }
}

// Represents pixel state on the map
#[wasm_bindgen]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct PixelState {
    element: Element,
    velocity_y: f32,
    // Flag to determine if the pixel is falling
    falling: bool,
    // How many ticks the pixel didnt move
    not_moved_count: u8,
    // Used to determine if the pixel was updated during a tick
    clock: u8,
}

#[wasm_bindgen]
impl PixelState {
    // Creates a new pixel state
    pub fn new(element: Element) -> PixelState {
        PixelState {
            element,
            velocity_y: 0f32,
            falling: true,
            not_moved_count: 0,
            clock: 0,
        }
    }

    pub fn element(&self) -> Element {
        self.element
    }

    pub fn velocity_y(&self) -> f32 {
        self.velocity_y
    }

    pub fn falling(&self) -> bool {
        self.falling
    }

    pub fn not_moved_count(&self) -> u8 {
        self.not_moved_count
    }
}

static EMPTY_PIXEL: Pixel = Pixel {
    element: Element::Empty,
    ra: 0,
    rb: 0,
    rc: 0,
};

static WALL_PIXEL: Pixel = Pixel {
    element: Element::Wall,
    ra: 0,
    rb: 0,
    rc: 0,
};

pub static EMPTY_PIXEL_STATE: PixelState = PixelState {
    element: Element::Empty,
    velocity_y: 0f32,
    falling: false,
    not_moved_count: 0,
    clock: 0,
};

pub static WALL_PIXEL_STATE: PixelState = PixelState {
    element: Element::Wall,
    velocity_y: 0f32,
    falling: false,
    not_moved_count: 0,
    clock: 0,
};

// Represents a square chunk in the map which can be processed independently
#[wasm_bindgen]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Chunk {
    x: i32,
    y: i32,
    active: bool,
    active_next_tick: bool,
}

#[wasm_bindgen]
impl Chunk {
    pub fn new(x: i32, y: i32) -> Chunk {
        Chunk { x, y, active: true, active_next_tick: true }
    }

    pub fn x(&self) -> i32 {
        self.x
    }

    pub fn y(&self) -> i32 {
        self.y
    }

    pub fn active(&self) -> bool {
        self.active
    }

    pub fn active_next_tick(&self) -> bool {
        self.active_next_tick
    }
}

// Represents a map configuration
#[wasm_bindgen]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MapConfig {
    pub size: i32,
    pub gravity: f32,
    pub max_velocity: f32,
    pub use_chunks: bool,
    pub chunk_size: i32,
    pub seed: u16,
}

#[wasm_bindgen]
impl MapConfig {
    pub fn new(size: i32, gravity: f32, max_velocity: f32,
               use_chunks: bool, chunk_size: i32, seed: u16) -> MapConfig {
        MapConfig {
            size,
            gravity,
            max_velocity,
            use_chunks,
            chunk_size,
            seed,
        }
    }
}

// Represents a map composed of pixels
#[wasm_bindgen]
pub struct Map {
    config: MapConfig,
    pixels: Vec<Pixel>,
    pixel_states: Vec<PixelState>,
    chunks: Vec<Chunk>,
    // The dimension of chunk vector
    chunk_dim: i32,
    // Used to determine which pixels were updated during a tick
    clock: u8,
    random: Random,
    // How much ticks pixel does not have to move and still be updated
    not_moved_threshold: u8,
}

#[wasm_bindgen]
impl Map {
    // Create a new empty map
    pub fn new_empty(config: MapConfig) -> Map {
        Map::new(config, MapGenerator::EMPTY)
    }

    // Create a new cave map
    pub fn new_cave(config: MapConfig) -> Map {
        Map::new(config, MapGenerator::CAVE)
    }

    // Creates a new map generated by given generator
    pub fn new(config: MapConfig, generator: MapGenerator) -> Map {
        console_error_panic_hook::set_once();

        let pixel_states = generator.generate_map(&config);

        let pixels = (&pixel_states)
            .into_iter()
            .map(|state| {
                Pixel {
                    element: state.element,
                    ra: 0,
                    rb: 0,
                    rc: 0
                }
            })
            .collect();

        let chunks = if config.use_chunks {
            Map::generate_chunks(config.size, config.chunk_size)
        } else {
            vec![]
        };

        let chunk_dim = if config.use_chunks {
            config.size / config.chunk_size
        } else {0};

        let random = Random::new(config.seed);

        let not_moved_threshold = (1f32 / config.gravity).clamp(1f32, 10f32) as u8;

        Map {
            config,
            pixels,
            pixel_states,
            chunks,
            chunk_dim,
            clock: 0,
            random,
            not_moved_threshold,
        }
    }

    // Inserts a new pixels of given element in radius from x,y
    pub fn insert(&mut self, x: i32, y: i32, element: Element, radius: i32) {
        for i in -radius..=radius {
            for j in -radius..=radius {
                if i*i + j*j <= radius*radius {
                    self.insert_pixel(x+i, y+j, element);
                }
            }
        }
    }

    // Clears the map so its empty
    pub fn clear(&mut self) {
        self.clock = 0;

        for x in 0..self.config.size {
            for y in 0..self.config.size {
                let index = self.pixel_index(x, y);
                self.pixels[index] = EMPTY_PIXEL;
                self.pixel_states[index] = EMPTY_PIXEL_STATE;
            }
        }
    }

    // Simulates a tick and return number of processed pixels
    pub fn tick(&mut self) -> u32 {
        self.reset_chunks();
        self.clock = self.clock.wrapping_add(1);

        let pixels:u32 = if self.config.use_chunks {
            self.process_chunks()
        } else {
            self.process_pixels(0, 0, self.config.size, self.config.size)
        };

        return pixels;
    }

    pub fn size(&self) -> i32 {
        self.config.size
    }

    pub fn pixels(&self) -> *const Pixel {
        self.pixels.as_ptr()
    }

    pub fn pixel(&self, x: i32, y: i32) -> Pixel {
        if self.out_of_bounds(x, y) {
            return WALL_PIXEL;
        }

        return self.pixels[self.pixel_index(x, y)];
    }

    pub fn pixel_state(&self, x: i32, y: i32) -> PixelState {
        if self.out_of_bounds(x, y) {
            return WALL_PIXEL_STATE;
        }

        return self.pixel_states[self.pixel_index(x, y)];
    }

    pub fn chunk(&self, i: usize) -> Chunk {
        self.chunks[i]
    }

    pub fn chunks_count(&self) -> usize {
        self.chunks.len()
    }
}

impl Map {
    // Return index in pixels vector for given x,y
    fn pixel_index(&self, x: i32, y: i32) -> usize {
        (x + (y * self.config.size)) as usize
    }

    // Return index in chunk vector for given x,y
    fn chunk_index(&self, x: i32, y: i32) -> usize {
        (x + (y * self.chunk_dim)) as usize
    }

    // Update given pixel
    fn update_pixel(pixel: &mut PixelState, api: &mut MapApi) -> bool {
        if Map::can_update(pixel, api) {
            pixel.clock = api.map.clock;
            Element::update(pixel, api);
            return true;
        }
        return false;
    }

    // Return true if a pixel can be updated
    fn can_update(pixel: &mut PixelState, api: &MapApi) -> bool {
        // TODO: add checking for static, not concrete elements
        match pixel.element {
            Element::Empty => false,
            Element::Wall => false,
            _ => pixel.clock != api.map.clock
        }
    }

    // Inserts a new pixel of given element at x,y
    fn insert_pixel(&mut self, x: i32, y: i32, element: Element) {
        if self.out_of_bounds(x, y) {
            return;
        }

        if self.pixel_state(x, y).element() == Element::Empty || element == Element::Empty {
            let index = self.pixel_index(x, y);

            self.pixels[index] = Pixel::new(element);
            self.pixel_states[index] = PixelState {
                element,
                velocity_y: 0f32,
                falling: false,
                not_moved_count: 0,
                clock: self.clock,
            };

            self.activate_surrounding_pixels(x, y);
        }
    }

    // Generates chunks of given size for map of given size and return them
    fn generate_chunks(map_size: i32, chunk_size: i32) -> Vec<Chunk> {
        return (0..map_size).step_by(chunk_size as usize)
            .into_iter()
            .flat_map(|y| {
                return (0..map_size).step_by(chunk_size as usize)
                    .into_iter()
                    .map(move |x| {
                        Chunk::new(x, y)
                    })
            })
            .collect();
    }

    // Resets chunks for next tick
    fn reset_chunks(&mut self) {
        for mut chunk in self.chunks.iter_mut() {
            chunk.active = chunk.active_next_tick;
            chunk.active_next_tick = false;
        }
    }

    // Marks a chunk for given pixel position active for next tick
    fn set_chunk_active_next_tick(&mut self, pixel_x: i32, pixel_y: i32) {
        if self.config.use_chunks {
            let chunk_x = pixel_x / self.config.chunk_size;
            let chunk_y = pixel_y / self.config.chunk_size;
            let index = self.chunk_index(chunk_x, chunk_y);

            match self.chunks.get_mut(index) {
                Some(chunk) => {
                    chunk.active_next_tick = true
                }
                None => {}
            }
        }
    }

    // Process all active chunks and pixels they contain
    fn process_chunks(&mut self) -> u32 {
        let mut pixels = 0;

        // Process chunks from bottom
        for chunk_y in (0..self.chunk_dim).rev() {
            for chunk_x in 0..self.chunk_dim {
                // process chunks from different side each tick
                let chunk_scan_x = if self.clock % 2 == 0 {
                    self.chunk_dim - (1 + chunk_x)
                } else {
                    chunk_x
                };

                let chunk = self.chunk(self.chunk_index(chunk_scan_x, chunk_y));

                if chunk.active {
                    pixels += self.process_pixels(
                        chunk.x,
                        chunk.y,
                        chunk.x + self.config.chunk_size,
                        chunk.y + self.config.chunk_size);
                }
            }
        }

        return pixels;
    }

    // Process pixels within given rectangle area
    fn process_pixels(&mut self, x_from: i32, y_from: i32, x_to: i32, y_to: i32) -> u32 {
        let mut pixels = 0;

        // Process pixels from bottom
        for y in (y_from..y_to).rev() {
            for x in x_from..x_to {
                // process pixels from different side each tick
                let scan_x = if self.clock % 2 == 0 {
                    x_from + x_to - (1 + x)
                } else {
                    x
                };

                pixels += Map::update_pixel(
                    &mut self.pixel_state(scan_x, y),
                    &mut MapApi::new(scan_x, y, self)) as u32;
            }
        }

        return pixels;
    }

    // Activates pixel on given position by activating corresponding chunk
    fn activate_pixel(&mut self, x: i32, y: i32) {
        if self.out_of_bounds(x, y) {
            return;
        }

        self.set_chunk_active_next_tick(x, y)
    }

    // Activates pixel on given position and all its surrounding pixels
    // by activating corresponding chunks
    fn activate_surrounding_pixels(&mut self, x: i32, y: i32) {
        for dir_x in -1..=1 {
            for dir_y in -1..=1 {
                self.activate_pixel(x+dir_x, y+dir_y);

                // Mark solid pixels above with falling flag
                if dir_y == -1 {
                    let index = self.pixel_index(x+dir_x, y+dir_y);

                    // TODO: add checking for solid, not concrete elements
                    match self.pixel_states[index].element {
                        Element::Sand => self.pixel_states[index].falling = true,
                        _ => {}
                    }
                }
            }
        }
    }

    // Return true if given position is out of bounds of the map
    fn out_of_bounds(&self, x: i32, y: i32) -> bool {
        return x < 0 || x > self.config.size - 1 || y < 0 || y > self.config.size - 1
    }
}

// Map API which pixels can use to define its behavior
pub struct MapApi<'a> {
    x: i32,
    y: i32,
    map: &'a mut Map,
}

impl<'a> MapApi<'a> {
    // Creates a new Map api for pixel at x, y
    pub fn new(x: i32, y: i32, map: &'a mut Map) -> MapApi {
        MapApi {
            x,
            y,
            map,
        }
    }

    // Return gravity
    pub fn gravity(&self) -> f32 {
        return self.map.config.gravity;
    }

    // Adds velocity to given pixel
    pub fn add_velocity(&mut self, pixel: &mut PixelState, velocity: f32) {
        self.set_velocity(pixel, pixel.velocity_y + velocity);
    }

    // Set velocity to given pixel
    pub fn set_velocity(&mut self, pixel: &mut PixelState, velocity: f32) {
        pixel.velocity_y = velocity.clamp(
            -self.map.config.max_velocity, self.map.config.max_velocity);
    }

    // Set falling flag to given pixel
    pub fn set_falling(&mut self, pixel: &mut PixelState, falling: bool) {
        pixel.falling = falling;
    }

    // Returns a pixel in direction (dx, dy) relative to current pixel
    pub fn pixel(&mut self, dx: i32, dy: i32) -> PixelState {
        let nx = self.x + dx;
        let ny = self.y + dy;

        self.map.pixel_state(nx, ny)
    }

    // Sets a pixel at to a direction (dx, dy) relative to current pixel
    pub fn set_pixel(&mut self, dx: i32, dy: i32, pixel: &PixelState) {
        let nx = self.x + dx;
        let ny = self.y + dy;

        if self.map.out_of_bounds(nx, ny) {
            return;
        }

        let index = self.map.pixel_index(nx, ny);

        self.map.pixels[index] = Pixel::new(pixel.element);
        self.map.pixel_states[index] = *pixel;
    }

    // Activates pixel on given relative position, so it will be processed next tick
    pub fn activate_pixel(&mut self, dx: i32, dy: i32) {
        self.map.activate_pixel(self.x + dx, self.y + dy)
    }

    // Activates pixel on given relative position and all its surrounding pixels
    // so they will be processed next tick
    pub fn activate_surrounding_pixels(&mut self, dx: i32, dy: i32) {
        self.map.activate_surrounding_pixels(self.x + dx, self.y + dy);
    }

    // Activates the pixel when moved with respect to given not moved threshold
    // so even when a pixel does not move with less ticks then this threshold, we will
    // still update it
    pub fn activate_when_moved(&mut self, pixel: &mut PixelState) {
        if pixel.not_moved_count() >= self.map.not_moved_threshold {
            pixel.not_moved_count = self.map.not_moved_threshold;
            self.set_pixel(0, 0, pixel);
        }

        if pixel.falling || pixel.not_moved_count < self.map.not_moved_threshold {
            self.activate_pixel(0, 0);
        }
    }

    // Compute a path in the map of the pixel according to its velocity and pass that context
    // to given function which should decide what to do by providing the result
    pub fn move_by_velocity(&mut self,
                            pixel: &mut PixelState,
                            move_f: fn(&mut PixelState, &mut MapApi, &MoveContext) -> MoveResult) {
        let sign_y = if pixel.velocity_y() > 0f32 {1} else {-1};
        let velocity_y = (pixel.velocity_y().abs()) as i32;

        // Keep track of last valid position during the movement
        let last_valid_x = 0;
        let mut last_valid_y = 0;

        if velocity_y >= 1 {
            for move_y in 1..=velocity_y {
                let contact = self.pixel(0, move_y * sign_y);

                let result = move_f(pixel, self, &MoveContext::new(
                    0,
                    move_y * sign_y,
                    &contact,
                    move_y == 1,
                    move_y == velocity_y,
                    last_valid_x,
                    last_valid_y));

                match result {
                    // Continue moving along the path and update last valid position
                    MoveResult::CONTINUE => {
                        last_valid_y = move_y * sign_y;
                        continue
                    },
                    // Finalize the movement by swapping the pixels and activating them
                    MoveResult::MOVE {x,y} => {
                        if x != 0 || y != 0 {
                            // Swap the pixels and activate them
                            let target_pixel = self.pixel(x, y);

                            // Reset not moved count flag
                            pixel.not_moved_count = 0;

                            self.set_pixel(0, 0, &target_pixel);
                            self.activate_surrounding_pixels(0, 0);
                            self.set_pixel(x, y, pixel);
                            self.activate_surrounding_pixels(x, y);

                            return;
                        }
                        break;
                    },
                }
            }
        }

        // If we did not move, increment not moved count,and update itself
        // so the changes are stored
        pixel.not_moved_count += 1;
        self.set_pixel(0, 0, pixel);
    }

    // Move to a neighbor position using given unit direction and pass a new context
    // to given function which should do the actual movement
    //
    // This can only be called inside move function where the move context is available
    pub fn move_by_direction(&mut self,
                             pixel: &mut PixelState,
                             direction_x: i32,
                             direction_y: i32,
                             context: &MoveContext,
                             move_f: fn(&mut PixelState,
                                        &mut MapApi,
                                        &MoveContext) -> MoveResult) -> MoveResult {
        let contact = self.pixel(
            context.x + direction_x,
            context.y + direction_y);

        return move_f(pixel, self, &MoveContext::new(
            context.x + direction_x,
            context.y + direction_y,
            &contact,
            false,
            true,
            context.last_valid_x,
            context.last_valid_y));
    }

    // Returns random index from given probability distribution
    pub fn rand(&mut self, distribution: &[f32]) -> usize {
        let mut random = self.map.random.next();

        for (i, prob) in distribution.iter().enumerate() {
            if random <= *prob {
                return i;
            } else {
                random -= prob;
            }
        }

        distribution.len() - 1
    }
}

pub struct MoveContext<'a> {
    pub x: i32,
    pub y: i32,
    pub contact: &'a PixelState,
    pub first_move: bool,
    pub last_move: bool,
    pub last_valid_x: i32,
    pub last_valid_y: i32,
}

impl<'a> MoveContext<'a> {
    pub fn new(x: i32,
               y: i32,
               contact: &PixelState,
               first_move: bool,
               last_move: bool,
               last_valid_x: i32,
               last_valid_y: i32) -> MoveContext {
        MoveContext {
            x, y, contact, first_move, last_move, last_valid_x, last_valid_y
        }
    }
}

pub enum MoveResult {
    CONTINUE,
    MOVE {x: i32, y: i32}
}