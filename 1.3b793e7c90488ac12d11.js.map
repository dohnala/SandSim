{"version":3,"sources":["webpack:///../engine/pkg/engine_bg.js","webpack:///./render/shaders/background.vert","webpack:///./render/shaders/background.frag","webpack:///./render/shaders/map.vert","webpack:///./render/shaders/map.frag","webpack:///./render/shaders/chunk.vert","webpack:///./render/shaders/chunk.frag","webpack:///./vars.js","webpack:///./performance.js","webpack:///./ui.js","webpack:///./main.js","webpack:///./render/render.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","wasm","Uint8Array","getStringFromWasm0","ptr","len","subarray","_assertClass","instance","klass","Error","name","cachegetInt32Memory0","getInt32Memory0","Int32Array","cachegetFloat32Memory0","getFloat32Memory0","Float32Array","isLikeNone","x","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","MapGenerator","Object","freeze","EMPTY","CAVE","Element","Empty","Wall","Sand","Dirt","Water","Chunk","this","__destroy_into_raw","obj","create","prototype","Map","y","element","radius","MapConfig","__wrap","PixelInfo","i","config","ptr0","generator","arg0","size","gravity","max_velocity","use_chunks","chunk_size","seed","retptr","r0","r1","__wbg_new_59cb74e423758ede","addHeapObject","__wbg_stack_558ba5917b466edd","arg1","malloc","realloc","mem","offset","code","charCodeAt","slice","passStringToWasm0","stack","len0","__wbg_error_4bb6c2a97407129a","console","error","__wbindgen_object_drop_ref","__wbindgen_throw","exports","backgroundColor","elements","key","value","hsv","alpha","params","mapSizes","chunkSizes","mapGenerators","elementColorsArray","result","hasOwnProperty","concat","fpsLabel","document","getElementById","meanRenderTimeLabel","meanTickTimeLabel","lastTickTimeLabel","meanPixelsProcessedLabel","lastPixelsProcessedLabel","fps","mean","delta","frames","lastFrameTimeStamp","performance","now","measure","diff","shift","measureMean","renderTime","last","startTime","start","stop","window","paused","frameTime","tickTime","textContent","Math","round","pixelsProcessed","pixels","percentage","reset","array","sum","max","setInterval","$","canvas","ready","addMapSizes","addChunkSizes","addMapGenerators","addElements","updateCreateForm","createButton","generateSeedButton","useChunksCheckbox","chunkSizeSelect","showActiveChunks","showActiveChunksCheckbox","click","Number","val","clamp","maxVelocity","useChunks","is","chunkSize","mapGeneratorByName","createMap","generateSeed","prop","forEach","option","append","change","checked","playButton","pauseButton","nextFrameButton","resetButton","hide","addClass","togglePause","nextFrame","resetMap","keypress","event","keyCode","show","removeClass","nextTick","map","clear","selectedElement","elementColor","h","s","v","f","n","k","min","join","radio","attr","brushSize","step","brushSizeSlider","on","bind","originalEvent","wheelDelta","detail","inspectPixelPosition","inspecting","inspectRepeat","inspectCheckBox","inspectDetails","clearInterval","inspectPixel","pixel","pixel_info","text","velocity_x","velocity_y","falling","not_moved_count","painting","lastPaint","repeat","addEventListener","preventDefault","paint","body","smoothPaint","getPixelPosition","findInspectPixelPosition","drawMap","pixelPosition","insert","startEvent","clientX","clientY","eventDistance","d","add","scale","norm","sub","boundingRect","getBoundingClientRect","scaleX","width","ceil","devicePixelRatio","scaleY","height","canvasLeft","left","canvasTop","top","floor","a","b","sqrt","pow","mag","magnitude","reglBuilder","background_vert","background_frag","map_vert","map_frag","chunk_vert","chunk_frag","startWebGL","regl","extensions","elementTextureDim","elementTexture","texture","type","data","mapSize","mapTexture","memory","display","drawBackground","vert","frag","uniforms","color","depth","enable","attributes","position","count","time","tick","element_texture_dim","element_texture","map_size","map_texture","blend","func","srcRGB","srcAlpha","dstRGB","dstAlpha","drawChunk","lineWidth","primitive","chunks","chunks_count","chunk","drawDebugInfo","filter","_","index","active_next_tick","poll","random","renderLoop","animationId","requestAnimationFrame"],"mappings":"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","file":"1.3b793e7c90488ac12d11.js","sourcesContent":["import * as wasm from './engine_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nlet cachegetFloat32Memory0 = null;\nfunction getFloat32Memory0() {\n    if (cachegetFloat32Memory0 === null || cachegetFloat32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachegetFloat32Memory0;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n/**\n*/\nexport const MapGenerator = Object.freeze({ EMPTY:0,\"0\":\"EMPTY\",CAVE:1,\"1\":\"CAVE\", });\n/**\n*/\nexport const Element = Object.freeze({ Empty:0,\"0\":\"Empty\",Wall:1,\"1\":\"Wall\",Sand:2,\"2\":\"Sand\",Dirt:3,\"3\":\"Dirt\",Water:4,\"4\":\"Water\", });\n/**\n*/\nexport class Chunk {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Chunk.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_chunk_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    x() {\n        var ret = wasm.__wbg_get_mapconfig_size(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    y() {\n        var ret = wasm.chunk_y(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {boolean}\n    */\n    active() {\n        var ret = wasm.chunk_active(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    active_next_tick() {\n        var ret = wasm.chunk_active_next_tick(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class Map {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Map.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_map_free(ptr);\n    }\n    /**\n    * @param {MapConfig} config\n    * @returns {Map}\n    */\n    static new_empty(config) {\n        _assertClass(config, MapConfig);\n        var ptr0 = config.ptr;\n        config.ptr = 0;\n        var ret = wasm.map_new_empty(ptr0);\n        return Map.__wrap(ret);\n    }\n    /**\n    * @param {MapConfig} config\n    * @returns {Map}\n    */\n    static new_cave(config) {\n        _assertClass(config, MapConfig);\n        var ptr0 = config.ptr;\n        config.ptr = 0;\n        var ret = wasm.map_new_cave(ptr0);\n        return Map.__wrap(ret);\n    }\n    /**\n    * @param {MapConfig} config\n    * @param {number} generator\n    * @returns {Map}\n    */\n    static new(config, generator) {\n        _assertClass(config, MapConfig);\n        var ptr0 = config.ptr;\n        config.ptr = 0;\n        var ret = wasm.map_new(ptr0, generator);\n        return Map.__wrap(ret);\n    }\n    /**\n    * @param {number} x\n    * @param {number} y\n    * @param {number} element\n    * @param {number} radius\n    */\n    insert(x, y, element, radius) {\n        wasm.map_insert(this.ptr, x, y, element, radius);\n    }\n    /**\n    */\n    clear() {\n        wasm.map_clear(this.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    tick() {\n        var ret = wasm.map_tick(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {MapConfig}\n    */\n    config() {\n        var ret = wasm.map_config(this.ptr);\n        return MapConfig.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    display() {\n        var ret = wasm.map_display(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} x\n    * @param {number} y\n    * @returns {PixelInfo | undefined}\n    */\n    pixel_info(x, y) {\n        var ret = wasm.map_pixel_info(this.ptr, x, y);\n        return ret === 0 ? undefined : PixelInfo.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    chunks_count() {\n        var ret = wasm.map_chunks_count(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {Chunk}\n    */\n    chunk(i) {\n        var ret = wasm.map_chunk(this.ptr, i);\n        return Chunk.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MapConfig {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MapConfig.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mapconfig_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get size() {\n        var ret = wasm.__wbg_get_mapconfig_size(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set size(arg0) {\n        wasm.__wbg_set_mapconfig_size(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get gravity() {\n        var ret = wasm.__wbg_get_mapconfig_gravity(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set gravity(arg0) {\n        wasm.__wbg_set_mapconfig_gravity(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get max_velocity() {\n        var ret = wasm.__wbg_get_mapconfig_max_velocity(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set max_velocity(arg0) {\n        wasm.__wbg_set_mapconfig_max_velocity(this.ptr, arg0);\n    }\n    /**\n    * @returns {boolean}\n    */\n    get use_chunks() {\n        var ret = wasm.__wbg_get_mapconfig_use_chunks(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} arg0\n    */\n    set use_chunks(arg0) {\n        wasm.__wbg_set_mapconfig_use_chunks(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get chunk_size() {\n        var ret = wasm.__wbg_get_mapconfig_chunk_size(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set chunk_size(arg0) {\n        wasm.__wbg_set_mapconfig_chunk_size(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get seed() {\n        var ret = wasm.__wbg_get_mapconfig_seed(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set seed(arg0) {\n        wasm.__wbg_set_mapconfig_seed(this.ptr, arg0);\n    }\n    /**\n    * @param {number} size\n    * @param {number} gravity\n    * @param {number} max_velocity\n    * @param {boolean} use_chunks\n    * @param {number} chunk_size\n    * @param {number} seed\n    * @returns {MapConfig}\n    */\n    static new(size, gravity, max_velocity, use_chunks, chunk_size, seed) {\n        var ret = wasm.mapconfig_new(size, gravity, max_velocity, use_chunks, chunk_size, seed);\n        return MapConfig.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PixelDisplayInfo {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pixeldisplayinfo_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get element() {\n        var ret = wasm.__wbg_get_pixeldisplayinfo_element(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set element(arg0) {\n        wasm.__wbg_set_pixeldisplayinfo_element(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get ra() {\n        var ret = wasm.__wbg_get_pixeldisplayinfo_ra(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set ra(arg0) {\n        wasm.__wbg_set_pixeldisplayinfo_ra(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get rb() {\n        var ret = wasm.__wbg_get_pixeldisplayinfo_rb(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set rb(arg0) {\n        wasm.__wbg_set_pixeldisplayinfo_rb(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get rc() {\n        var ret = wasm.__wbg_get_pixeldisplayinfo_rc(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set rc(arg0) {\n        wasm.__wbg_set_pixeldisplayinfo_rc(this.ptr, arg0);\n    }\n}\n/**\n*/\nexport class PixelInfo {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PixelInfo.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pixelinfo_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get element() {\n        var ret = wasm.__wbg_get_pixelinfo_element(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set element(arg0) {\n        wasm.__wbg_set_pixelinfo_element(this.ptr, arg0);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get friction() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_pixelinfo_friction(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number | undefined} arg0\n    */\n    set friction(arg0) {\n        wasm.__wbg_set_pixelinfo_friction(this.ptr, !isLikeNone(arg0), isLikeNone(arg0) ? 0 : arg0);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get restitution() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_pixelinfo_restitution(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number | undefined} arg0\n    */\n    set restitution(arg0) {\n        wasm.__wbg_set_pixelinfo_restitution(this.ptr, !isLikeNone(arg0), isLikeNone(arg0) ? 0 : arg0);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get inertia() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_pixelinfo_inertia(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number | undefined} arg0\n    */\n    set inertia(arg0) {\n        wasm.__wbg_set_pixelinfo_inertia(this.ptr, !isLikeNone(arg0), isLikeNone(arg0) ? 0 : arg0);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get velocity_x() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_pixelinfo_velocity_x(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number | undefined} arg0\n    */\n    set velocity_x(arg0) {\n        wasm.__wbg_set_pixelinfo_velocity_x(this.ptr, !isLikeNone(arg0), isLikeNone(arg0) ? 0 : arg0);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get velocity_y() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_pixelinfo_velocity_y(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number | undefined} arg0\n    */\n    set velocity_y(arg0) {\n        wasm.__wbg_set_pixelinfo_velocity_y(this.ptr, !isLikeNone(arg0), isLikeNone(arg0) ? 0 : arg0);\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    get falling() {\n        var ret = wasm.__wbg_get_pixelinfo_falling(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @param {boolean | undefined} arg0\n    */\n    set falling(arg0) {\n        wasm.__wbg_set_pixelinfo_falling(this.ptr, isLikeNone(arg0) ? 0xFFFFFF : arg0 ? 1 : 0);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get not_moved_count() {\n        var ret = wasm.__wbg_get_pixelinfo_not_moved_count(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n    * @param {number | undefined} arg0\n    */\n    set not_moved_count(arg0) {\n        wasm.__wbg_set_pixelinfo_not_moved_count(this.ptr, isLikeNone(arg0) ? 0xFFFFFF : arg0);\n    }\n}\n\nexport const __wbg_new_59cb74e423758ede = function() {\n    var ret = new Error();\n    return addHeapObject(ret);\n};\n\nexport const __wbg_stack_558ba5917b466edd = function(arg0, arg1) {\n    var ret = getObject(arg1).stack;\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport const __wbg_error_4bb6c2a97407129a = function(arg0, arg1) {\n    try {\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        wasm.__wbindgen_free(arg0, arg1);\n    }\n};\n\nexport const __wbindgen_object_drop_ref = function(arg0) {\n    takeObject(arg0);\n};\n\nexport const __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n","module.exports = \"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\n\\nvoid main() {\\n    gl_Position = vec4(position, 0, 1);\\n}\"","module.exports = \"precision mediump float;\\n#define GLSLIFY 1\\n\\nuniform vec4 color;\\n\\nvoid main () {\\n    gl_FragColor = color;\\n}\"","module.exports = \"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\nvarying vec2 uv;\\n\\nvoid main() {\\n    uv = position;\\n    gl_Position = vec4(position, 0, 1);\\n}\"","module.exports = \"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform float time;\\nuniform vec2 element_texture_dim;\\nuniform sampler2D element_texture;\\nuniform int map_size;\\nuniform sampler2D map_texture;\\n\\nvarying vec2 uv;\\n\\n// clang-format off\\nvec3 hsv2rgb(vec3 c) {\\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g_0 = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g_0;\\n  vec3 i1 = min( g_0.xyz, l.zxy );\\n  vec3 i2 = max( g_0.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\nvoid main() {\\n    vec2 map_texture_coord = (uv * vec2(0.5, -0.5)) + vec2(0.5);\\n\\n    // Pixel info contains information about how pixel should be rendered\\n    // pixel_info.r = element\\n    // pixel_infor.g = noise (only for solid elements)\\n    vec4 pixel_info = texture2D(map_texture, map_texture_coord);\\n\\n    // In order to get element, it need to be converted from float\\n    int element = int((pixel_info.r * 255.) + 0.1);\\n\\n    // Coordinate to load texture data for element\\n    float element_texture_coord = float(element)/float(element_texture_dim[1]);\\n    // Coordinate to load color for element\\n    float element_color_coord = 0.;\\n    // Coordinate to load params for element\\n    float element_params_coord = float(1)/float(element_texture_dim[0]);\\n\\n    // Element Color is in HSV + A format\\n    // color.x = Hue\\n    // color.y = Saturation\\n    // color.z = Value\\n    // color.a = Alpha\\n    vec4 color = texture2D(element_texture, vec2(element_color_coord, element_texture_coord));\\n\\n    // Element Parameters\\n    // params.x = Value modifier in range [0..1] - how much random value should be added to element Value\\n    // params.y = Noise speed - how frequently should be color of element changed\\n    // paramy.z = Noise Value modifier in range [0..1] - how much noise value should be added to element Value\\n    vec4 params = texture2D(element_texture, vec2(element_params_coord, element_texture_coord));\\n\\n    // Create noise from UV coordinates which changes based on element noise speed\\n    float noise = snoise(vec3(floor(uv * float(map_size/2)), time * params.y));\\n\\n    // Change element's Value according to value modifier and noise value modifier\\n    float value = color.z + pixel_info.g * params.x + noise * params.z;\\n\\n    color = vec4(color.x, color.y, value, color.w);\\n\\n    // Convert the color to RGBA\\n    gl_FragColor = vec4(hsv2rgb(vec3(color.xyz)), color.w);\\n}\"","module.exports = \"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\nuniform float scale;\\nuniform vec2 offset;\\n\\nvoid main () {\\n    vec2 p  = position;\\n    p *= scale;\\n    p += offset;\\n    gl_Position = vec4(p, 0, 1);\\n}\"","module.exports = \"precision mediump float;\\n#define GLSLIFY 1\\n\\nuniform vec4 color;\\n\\nvoid main () {\\n    gl_FragColor = color;\\n}\"","import {Element, MapGenerator} from \"engine\";\r\n\r\nconst backgroundColor = [0.31, 0.3, 0.3, 1];\r\n\r\n// Elements and their properties\r\n//\r\n// key - unique identification of the element, for now, they must be sorted in ascending incremental order (0, 1, 2, ..)\r\n// name - name of the element, used in UI\r\n// hsv - base HSV (Hue, Saturation, Value) color of the element\r\n//      - [0] - Hue, int in range [0..360]\r\n//      - [1] - Saturation, float in range [0..1]\r\n//      - [2] - Value, float in range [0..1]\r\n// alpha - transparency of the element in range [0..1]\r\n// params - additional dynamic parameters which affect element color in runtime\r\n//      - [0] - Value modifier in range [0..1]\r\n//            - if the modifier is 0.5 for example, it means that random number in range [0..0.5] will be added\r\n//              to the base value of HSV at runtime\r\n//      - [1] - Value noise speed in range [0..]\r\n//            - it determines how fast the element's Value is changed\r\n//      - [2] - Value noise modifier in range [0..1]\r\n//            - if the modifier is 0.5 for example, it means that random number in range [0..0.5] will be added\r\n//              to the base value of HSV at runtime with speed of [Value noise speed] parameter\r\nconst elements = [\r\n    {key: Element.Empty, value: {name: \"Empty\", hsv: [0,0,1], alpha: 0, params: [0,0,0,0]}},\r\n    {key: Element.Wall, value: {name: \"Wall\", hsv: [0,0,0], alpha: 1, params: [0,0,0,0]}},\r\n    {key: Element.Sand, value: {name: \"Sand\",  hsv: [46,0.5,0.5], alpha: 1, params: [0.2,0,0,0]}},\r\n    {key: Element.Dirt, value: {name: \"Dirt\", hsv: [18,0.6,0.3], alpha: 1, params: [0.1,0,0,0]}},\r\n    {key: Element.Water, value: {name: \"Water\", hsv: [222,0.7,0.65], alpha: 0.8, params: [0.1,0.015,0.1,0]}}\r\n];\r\n\r\nconst mapSizes = [64, 128, 256, 512];\r\nconst chunkSizes = [16, 32, 64];\r\n\r\nconst mapGenerators = [\r\n    {key: MapGenerator.EMPTY, value: {name: \"Empty\"}},\r\n    {key: MapGenerator.CAVE, value: {name: \"Cave\"}},];\r\n\r\nconst elementColorsArray = () => {\r\n    let result = [];\r\n\r\n    for (let key in elements) {\r\n        if (elements.hasOwnProperty(key)) {\r\n            result = result.concat(\r\n                [elements[key].value.hsv[0] / 360.],\r\n                [elements[key].value.hsv[1]],\r\n                [elements[key].value.hsv[2]],\r\n                [elements[key].value.alpha]);\r\n\r\n            result = result.concat(elements[key].value.params);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nconst elementColorsArrayDim = () => {\r\n    // height = 2 (color + params)\r\n    return [2, elements.length];\r\n}\r\n\r\nconst mapGeneratorByName = name => {\r\n    for (let key in mapGenerators) {\r\n        if (mapGenerators.hasOwnProperty(key)) {\r\n            if (mapGenerators[key].value.name === name) {\r\n                return key;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport {backgroundColor, elements, mapSizes, chunkSizes, mapGenerators,\r\n    elementColorsArray, elementColorsArrayDim, mapGeneratorByName}","import {config} from \"./main\";\r\n\r\nconst MEAN_FRAMES_SIZE = 100;\r\nconst PIXEL_PROCESSED_FRAMES_SIZE = 10;\r\n\r\nlet fpsLabel = document.getElementById(\"fps\");\r\nlet meanRenderTimeLabel = document.getElementById(\"meanRenderTime\");\r\nlet meanTickTimeLabel = document.getElementById(\"meanTickTime\");\r\nlet lastTickTimeLabel = document.getElementById(\"lastTickTime\");\r\nlet meanPixelsProcessedLabel = document.getElementById(\"meanPixelsProcessed\");\r\nlet lastPixelsProcessedLabel = document.getElementById(\"lastPixelsProcessed\");\r\n\r\nconst fps = {\r\n    mean: 0,\r\n    delta: 0,\r\n    frames: [],\r\n    lastFrameTimeStamp: performance.now(),\r\n\r\n    measure() {\r\n        const now = performance.now();\r\n        const diff = now - this.lastFrameTimeStamp;\r\n        this.lastFrameTimeStamp = now;\r\n        const fps = (1 / diff) * 1000;\r\n        this.delta = diff / 1000;\r\n\r\n        this.frames.push(fps);\r\n        if (this.frames.length > MEAN_FRAMES_SIZE) {\r\n            this.frames.shift();\r\n        }\r\n\r\n        this.mean = measureMean(this.frames);\r\n    }\r\n}\r\n\r\nconst renderTime = {\r\n    mean: 0,\r\n    last: 0,\r\n    frames: [],\r\n    startTime:  performance.now(),\r\n\r\n    start() {\r\n        this.startTime = performance.now();\r\n    },\r\n\r\n    stop() {\r\n        if (window.paused) return;\r\n\r\n        const now = performance.now();\r\n        const frameTime = now - this.startTime;\r\n\r\n        this.last = frameTime;\r\n\r\n        this.frames.push(frameTime);\r\n        if (this.frames.length > MEAN_FRAMES_SIZE) {\r\n            this.frames.shift();\r\n        }\r\n\r\n        this.mean = measureMean(this.frames);\r\n    }\r\n}\r\n\r\nconst tickTime = {\r\n    mean: 0,\r\n    last: 0,\r\n    frames: [],\r\n    startTime:  performance.now(),\r\n\r\n    start() {\r\n        this.startTime = performance.now();\r\n    },\r\n\r\n    stop() {\r\n        const now = performance.now();\r\n        const frameTime = now - this.startTime;\r\n\r\n        this.last = frameTime;\r\n\r\n        lastTickTimeLabel.textContent = window.paused ? `${Math.round(this.last)}ms` : \"\";\r\n\r\n        this.frames.push(frameTime);\r\n        if (this.frames.length > MEAN_FRAMES_SIZE) {\r\n            this.frames.shift();\r\n        }\r\n\r\n        this.mean = measureMean(this.frames);\r\n    }\r\n}\r\n\r\nconst pixelsProcessed = {\r\n    mean: 0,\r\n    last: 0,\r\n    frames: [],\r\n\r\n    measure(pixels) {\r\n        this.last = pixels;\r\n\r\n        lastPixelsProcessedLabel.textContent = window.paused ? `${Math.round(this.last)} \r\n        (${percentage(this.last, config.size*config.size)}%)` : \"\";\r\n\r\n        this.frames.push(pixels);\r\n        if (this.frames.length > PIXEL_PROCESSED_FRAMES_SIZE) {\r\n            this.frames.shift();\r\n        }\r\n\r\n        this.mean = measureMean(this.frames);\r\n    },\r\n\r\n    reset() {\r\n        this.mean = 0;\r\n        this.last = 0;\r\n        this.frames = [];\r\n    }\r\n}\r\n\r\nconst measureMean = array => {\r\n    let sum = 0;\r\n\r\n    for (let i = 0; i < array.length; i++) {\r\n        sum += array[i];\r\n    }\r\n\r\n    return  sum / array.length;\r\n}\r\n\r\nconst percentage = (value, max) => {\r\n    return Math.round((100 * value) / max);\r\n}\r\n\r\nconst updateLabels = () => {\r\n    fpsLabel.textContent = `FPS: ${Math.round(fps.mean)}`;\r\n    meanRenderTimeLabel.textContent = `${Math.round(renderTime.mean)}ms`;\r\n    meanTickTimeLabel.textContent = `${Math.round(tickTime.mean)}ms`;\r\n    meanPixelsProcessedLabel.textContent = `${Math.round(pixelsProcessed.mean)} \r\n    (${percentage(Math.round(pixelsProcessed.mean), config.size*config.size)}%)`;\r\n}\r\n\r\nsetInterval(updateLabels, 100);\r\n\r\nexport { fps, renderTime, tickTime, pixelsProcessed};","import {config, createMap, map, nextTick, generateSeed} from \"./main.js\";\r\nimport {elements, mapGenerators, mapGeneratorByName, mapSizes, chunkSizes} from \"./vars\";\r\nimport {pixelsProcessed, tickTime} from \"./performance\";\r\n\r\nvar $ = require( \"jquery\" );\r\n\r\nconst canvas = document.getElementById(\"canvas\");\r\n\r\n$('document').ready(function(){\r\n    addMapSizes();\r\n    addChunkSizes();\r\n    addMapGenerators();\r\n    addElements();\r\n    updateCreateForm()\r\n\r\n});\r\n\r\n// -----------------------------------------------------------------------------------------------\r\n//  CREATE MAP\r\n// -----------------------------------------------------------------------------------------------\r\nlet createButton = $('#create');\r\nlet generateSeedButton = $('#generateSeed');\r\nlet useChunksCheckbox = $('#configUseChunks');\r\nlet chunkSizeSelect = $('#configChunkSize');\r\nlet showActiveChunks = false;\r\nlet showActiveChunksCheckbox = $('#showActiveChunks');\r\n\r\ncreateButton.click(() => {\r\n    config.size = Number($('#configSize').val());\r\n    config.gravity = clamp($('#configGravity').val(), -1, 1);\r\n    config.maxVelocity = clamp($('#configMaxVelocity').val(), 0, 100);\r\n    config.useChunks = useChunksCheckbox.is(\":checked\");\r\n    config.chunkSize = Number(chunkSizeSelect.val());\r\n    config.generator = mapGeneratorByName($('#configGenerator').val());\r\n    config.seed = Number($('#seed').val());\r\n\r\n    createMap()\r\n    updateCreateForm();\r\n});\r\n\r\ngenerateSeedButton.click(() => {\r\n    config.seed = generateSeed();\r\n    updateCreateForm();\r\n});\r\n\r\nconst updateCreateForm = () => {\r\n    $('#configSize').val(config.size);\r\n    $('#configGravity').val(config.gravity);\r\n    $('#configMaxVelocity').val(config.maxVelocity);\r\n    $('#configGenerator').val(mapGenerators[config.generator].value.name);\r\n    $('#seed').val(config.seed);\r\n\r\n    useChunksCheckbox.prop('checked', config.useChunks);\r\n    chunkSizeSelect.val(config.chunkSize);\r\n    chunkSizeSelect.prop('disabled', !config.useChunks);\r\n}\r\n\r\nconst addMapSizes = () => {\r\n    mapSizes.forEach(function (value) {\r\n        let option = `<option>${value}</option>`;\r\n\r\n        $('#configSize').append(option);\r\n    });\r\n}\r\n\r\nconst addChunkSizes = () => {\r\n    chunkSizes.forEach(function (value) {\r\n        let option = `<option>${value}</option>`;\r\n\r\n        $('#configChunkSize').append(option);\r\n    });\r\n}\r\n\r\nconst addMapGenerators = () => {\r\n    for (let key in mapGenerators) {\r\n        if (mapGenerators.hasOwnProperty(key)) {\r\n            let option = `<option>${mapGenerators[key].value.name}</option>`;\r\n\r\n            $('#configGenerator').append(option);\r\n        }\r\n    }\r\n}\r\n\r\nuseChunksCheckbox.change(function() {\r\n    chunkSizeSelect.prop('disabled', !this.checked)\r\n    showActiveChunksCheckbox.prop('disabled', !this.checked)\r\n});\r\n\r\nshowActiveChunksCheckbox.change(function() {\r\n    showActiveChunks = this.checked;\r\n});\r\n\r\n// -----------------------------------------------------------------------------------------------\r\n//  ACTIONS\r\n// -----------------------------------------------------------------------------------------------\r\nlet paused = false;\r\nlet playButton = $('#play');\r\nlet pauseButton = $('#pause');\r\nlet nextFrameButton = $('#nextFrame');\r\nlet resetButton = $('#reset');\r\n\r\nplayButton.hide();\r\nnextFrameButton.addClass(\"disabled\");\r\n\r\nplayButton.click(() => togglePause());\r\npauseButton.click(() => togglePause());\r\nnextFrameButton.click(() => nextFrame());\r\nresetButton.click(() => resetMap());\r\n\r\n$('body').keypress(event => {\r\n    // P\r\n    if (event.keyCode === 112) {\r\n        togglePause();\r\n    }\r\n    // F\r\n    else if (event.keyCode === 102) {\r\n        nextFrame();\r\n    }\r\n    // R\r\n    else if (event.keyCode === 114) {\r\n        resetMap();\r\n    }\r\n})\r\n\r\nconst togglePause = () => {\r\n    paused = !paused;\r\n    window.paused = paused;\r\n\r\n    if (paused) {\r\n        playButton.show();\r\n        pauseButton.hide();\r\n        nextFrameButton.removeClass(\"disabled\");\r\n    } else {\r\n        playButton.hide();\r\n        pauseButton.show();\r\n        nextFrameButton.addClass(\"disabled\");\r\n    }\r\n}\r\n\r\nconst nextFrame = () => {\r\n    if (paused) {\r\n        tickTime.start();\r\n        pixelsProcessed.measure(nextTick());\r\n        tickTime.stop();\r\n    }\r\n}\r\n\r\nconst resetMap = () => {\r\n    map.clear();\r\n    pixelsProcessed.reset();\r\n}\r\n\r\n// -----------------------------------------------------------------------------------------------\r\n//  ELEMENTS\r\n// -----------------------------------------------------------------------------------------------\r\nlet selectedElement = null;\r\n\r\nconst hsv2rgb = (h, s, v) => {\r\n    let f = (n, k=(n+h/60)%6) => v - v*s*Math.max(Math.min(k,4-k,1),0);\r\n    return [f(5)*255.,f(3)*255.,f(1)*255.];\r\n}\r\n\r\nconst elementColor = element => {\r\n    let rgb = hsv2rgb(\r\n        elements[element].value.hsv[0],\r\n        elements[element].value.hsv[1],\r\n        elements[element].value.hsv[2]);\r\n\r\n    return \"rgb(\" + rgb.join(\",\") + \")\";\r\n}\r\n\r\nconst addElements = () => {\r\n    for (let key in elements) {\r\n        if (elements.hasOwnProperty(key)) {\r\n            let radio = `\r\n                <div class=\"form-check\">\r\n                    <input class=\"form-check-input\" type=\"radio\" name=\"flexRadioDefault\" id=\"element_${key}\">\r\n                    <label class=\"form-check-label\" for=\"element_${key}\">\r\n                        <i class=\"bi bi-square-fill\" style=\"color: ${elementColor(key)}\"></i>\r\n                        <label>${elements[key].value.name}</label>\r\n                    </label>\r\n                </div>`;\r\n\r\n            $('#painting').append(radio);\r\n            $('#element_' + key + '').change(() => selectedElement = Number(key));\r\n        }\r\n    }\r\n\r\n    // Select Sand by default\r\n    selectedElement = 2;\r\n    $('#element_2').attr('checked', true)\r\n}\r\n\r\n// -----------------------------------------------------------------------------------------------\r\n//  BRUSH SETTINGS\r\n// -----------------------------------------------------------------------------------------------\r\nlet brushSize = {\r\n    value: 0,\r\n    step: 1,\r\n    min: 0,\r\n    max: 5\r\n}\r\n\r\nlet brushSizeSlider = $('#brushSize');\r\n\r\nbrushSizeSlider.on(\"change\", function () {\r\n    brushSize.value = clamp(Number($(this).val()), brushSize.min, brushSize.max);\r\n});\r\n\r\n$(window).bind('mousewheel DOMMouseScroll', function(event){\r\n    if (event.originalEvent.wheelDelta > 0 || event.originalEvent.detail < 0) {\r\n        brushSize.value = clamp(brushSize.value + brushSize.step, brushSize.min, brushSize.max);\r\n        brushSizeSlider.val(brushSize.value);\r\n    } else {\r\n        brushSize.value = clamp(brushSize.value - brushSize.step, brushSize.min, brushSize.max);\r\n        brushSizeSlider.val(brushSize.value);\r\n    }\r\n});\r\n\r\n// -----------------------------------------------------------------------------------------------\r\n//  PIXEL INSPECTION\r\n// -----------------------------------------------------------------------------------------------\r\nlet inspectPixelPosition = null;\r\nlet inspecting = false;\r\nlet inspectRepeat = null;\r\nlet inspectCheckBox = $('#inspectCheck');\r\nlet inspectDetails = $('#inspectDetails');\r\n\r\ninspectDetails.hide();\r\n\r\ninspectCheckBox.click(() => {\r\n    if (inspectCheckBox.prop('checked')) {\r\n        inspecting = true;\r\n        clearInterval(inspectRepeat);\r\n        inspectRepeat = window.setInterval(() => inspectPixel(), 100);\r\n    } else {\r\n        inspecting = false;\r\n        clearInterval(inspectRepeat);\r\n    }\r\n})\r\n\r\nconst findInspectPixelPosition = event => {\r\n    if (inspectCheckBox.prop('checked')) {\r\n        inspectPixelPosition = getPixelPosition(event);\r\n    } else {\r\n        inspectPixelPosition = null;\r\n    }\r\n}\r\n\r\nconst inspectPixel = () => {\r\n    if (inspecting && inspectPixelPosition) {\r\n        let pixel = map.pixel_info(inspectPixelPosition[0], inspectPixelPosition[1])\r\n\r\n        if (pixel) {\r\n            inspectDetails.show();\r\n            $('#inspectElement').text(elements[pixel.element].value.name);\r\n            $('#inspectPosition').text(\"(\" + inspectPixelPosition[0] + \", \" + inspectPixelPosition[1] + \")\");\r\n\r\n            if (pixel.velocity_x !== undefined && pixel.velocity_y !== undefined) {\r\n                $('#inspectVelocity').text(\"(\" + pixel.velocity_x + \", \" + pixel.velocity_y + \")\");\r\n                $('#inspectVelocityRow').show();\r\n            } else {\r\n                $('#inspectVelocityRow').hide();\r\n            }\r\n\r\n            if (pixel.falling !== undefined) {\r\n                $('#inspectFalling').text(pixel.falling);\r\n                $('#inspectFallingRow').show();\r\n            } else {\r\n                $('#inspectFallingRow').hide();\r\n            }\r\n\r\n            if (pixel.not_moved_count !== undefined) {\r\n                $('#inspectNotMovedCount').text(pixel.not_moved_count);\r\n                $('#inspectNotMovedCountRow').show();\r\n            } else {\r\n                $('#inspectNotMovedCountRow').hide();\r\n            }\r\n        }\r\n    } else {\r\n        inspectDetails.hide();\r\n    }\r\n}\r\n\r\n// -----------------------------------------------------------------------------------------------\r\n//  PAINTING\r\n// -----------------------------------------------------------------------------------------------\r\nlet painting = false;\r\nlet lastPaint = null;\r\nlet repeat = null;\r\n\r\ncanvas.addEventListener(\"mousedown\", event => {\r\n    event.preventDefault();\r\n    painting = true;\r\n    clearInterval(repeat);\r\n    repeat = window.setInterval(() => paint(event), 100);\r\n    paint(event);\r\n    lastPaint = event;\r\n});\r\n\r\ndocument.body.addEventListener(\"mouseup\", event => {\r\n    clearInterval(repeat);\r\n    if (painting) {\r\n        event.preventDefault();\r\n        lastPaint = null;\r\n        painting = false;\r\n    }\r\n});\r\n\r\ncanvas.addEventListener(\"mousemove\", event => {\r\n    clearInterval(repeat);\r\n    smoothPaint(event);\r\n    findInspectPixelPosition(event);\r\n});\r\n\r\ncanvas.addEventListener(\"mouseleave\", () => {\r\n    clearInterval(repeat);\r\n    lastPaint = null;\r\n    inspectPixelPosition = null;\r\n});\r\n\r\nconst paint = event => {\r\n    if (!painting) {\r\n        return;\r\n    }\r\n\r\n    let pixelPosition = getPixelPosition(event);\r\n\r\n    map.insert(pixelPosition[0], pixelPosition[1], selectedElement, brushSize.value);\r\n};\r\n\r\nconst smoothPaint = event => {\r\n    clearInterval(repeat);\r\n    repeat = window.setInterval(() => paint(event), 100);\r\n\r\n    let startEvent = { clientX: event.clientX, clientY: event.clientY };\r\n\r\n    if (!painting) {\r\n        return;\r\n    }\r\n\r\n    let i = 0;\r\n    paint(startEvent);\r\n\r\n    if (lastPaint) {\r\n        while (eventDistance(startEvent, lastPaint) > 1 / 3) {\r\n            let d = eventDistance(startEvent, lastPaint);\r\n            startEvent = add(\r\n                startEvent,\r\n                scale(norm(sub(lastPaint, event)), Math.min(1 / 3, d))\r\n            );\r\n            i++;\r\n            if (i > 1000) {\r\n                break;\r\n            }\r\n            paint(startEvent);\r\n        }\r\n    }\r\n    lastPaint = event;\r\n}\r\n\r\n// -----------------------------------------------------------------------------------------------\r\n//  UTILS\r\n// -----------------------------------------------------------------------------------------------\r\n\r\nconst getPixelPosition = event => {\r\n    const boundingRect = canvas.getBoundingClientRect();\r\n\r\n    const scaleX = canvas.width / Math.ceil(window.devicePixelRatio) / boundingRect.width;\r\n    const scaleY = canvas.height / Math.ceil(window.devicePixelRatio) / boundingRect.height;\r\n\r\n    const canvasLeft = (event.clientX - boundingRect.left) * scaleX;\r\n    const canvasTop = (event.clientY - boundingRect.top) * scaleY;\r\n\r\n    const x = Math.max(Math.min(Math.floor(canvasLeft), config.size - 1), 0);\r\n    const y = Math.max(Math.min(Math.floor(canvasTop), config.size - 1), 0);\r\n\r\n    return [x, y];\r\n}\r\n\r\nconst eventDistance = (a, b) => {\r\n    return Math.sqrt(\r\n        Math.pow(a.clientX - b.clientX, 2) + Math.pow(a.clientY - b.clientY, 2),\r\n        2\r\n    );\r\n};\r\n\r\nconst add = (a, b) => {\r\n    return { clientX: a.clientX + b.clientX, clientY: a.clientY + b.clientY };\r\n};\r\n\r\nconst sub = (a, b) => {\r\n    return { clientX: a.clientX - b.clientX, clientY: a.clientY - b.clientY };\r\n};\r\n\r\nconst norm = a => {\r\n    let mag = magnitude(a);\r\n    return { clientX: a.clientX / mag, clientY: a.clientY / mag };\r\n};\r\n\r\nconst scale = (a, s) => {\r\n    return { clientX: a.clientX * s, clientY: a.clientY * s };\r\n};\r\n\r\nconst magnitude = a => {\r\n    return Math.sqrt(Math.pow(a.clientX, 2) + Math.pow(a.clientY, 2), 2);\r\n};\r\n\r\nconst clamp = function(value, min, max) {\r\n    return Math.min(Math.max(value, min), max);\r\n};\r\n\r\nexport {showActiveChunks}","import {Map, MapConfig, MapGenerator} from \"./node_modules/engine/engine.js\";\r\nimport { startWebGL } from \"./render/render\";\r\nimport {} from \"./ui\";\r\nimport {fps, pixelsProcessed, renderTime, tickTime} from \"./performance\";\r\n\r\nconst generateSeed = () => {\r\n    return Math.floor(Math.random() * Math.floor(10000));\r\n}\r\n\r\nlet config = {\r\n    size: 256,\r\n    gravity: 0.2,\r\n    maxVelocity: 10,\r\n    useChunks: true,\r\n    chunkSize: 32,\r\n    generator: MapGenerator.EMPTY,\r\n    seed: 1,\r\n}\r\n\r\nlet map;\r\nlet drawMap;\r\n\r\nconst canvas = document.getElementById(\"canvas\");\r\n\r\nconst createMap = () => {\r\n    map = Map.new(MapConfig.new(\r\n        config.size,\r\n        config.gravity,\r\n        config.maxVelocity,\r\n        config.useChunks,\r\n        config.chunkSize,\r\n        config.seed),\r\n        Number(config.generator));\r\n    canvas.width = config.size * Math.ceil(window.devicePixelRatio);\r\n    canvas.height = config.size * Math.ceil(window.devicePixelRatio);\r\n    drawMap = startWebGL({ canvas, map, config });\r\n\r\n    pixelsProcessed.reset();\r\n}\r\n\r\ncreateMap();\r\n\r\nconst renderLoop = () => {\r\n    fps.measure();\r\n\r\n    if (!window.paused) {\r\n        tickTime.start();\r\n        pixelsProcessed.measure(nextTick());\r\n        tickTime.stop();\r\n    }\r\n\r\n    renderTime.start();\r\n    drawMap();\r\n    renderTime.stop();\r\n\r\n    window.animationId = requestAnimationFrame(renderLoop);\r\n};\r\n\r\nconst nextTick = () => {\r\n    return map.tick(fps.delta);\r\n}\r\n\r\nrenderLoop();\r\n\r\nexport { canvas, config, map, createMap, nextTick, generateSeed};","import {backgroundColor, elementColorsArray, elementColorsArrayDim} from \"../vars\";\r\nimport {showActiveChunks} from \"../ui\";\r\nimport { memory } from \"engine/engine_bg\";\r\n\r\nconst reglBuilder = require(\"regl\");\r\n\r\nlet background_vert = require(\"./shaders/background.vert\");\r\nlet background_frag = require(\"./shaders/background.frag\");\r\nlet map_vert = require(\"./shaders/map.vert\");\r\nlet map_frag = require(\"./shaders/map.frag\");\r\nlet chunk_vert = require(\"./shaders/chunk.vert\");\r\nlet chunk_frag = require(\"./shaders/chunk.frag\");\r\n\r\nlet startWebGL = ({ canvas, map, config }) => {\r\n    const regl = reglBuilder({\r\n        extensions: ['OES_texture_float'],\r\n        canvas: canvas,\r\n    });\r\n\r\n    const elementTextureDim = elementColorsArrayDim();\r\n\r\n    // Texture with colors for all elements\r\n    const elementTexture = regl.texture({\r\n        width: elementTextureDim[0],\r\n        height: elementTextureDim[1],\r\n        type: 'float',\r\n        data: elementColorsArray(),\r\n    });\r\n\r\n    const mapSize = map.config().size;\r\n\r\n    // Texture with map pixels\r\n    const mapTexture = regl.texture({\r\n        width: mapSize,\r\n        height: mapSize,\r\n        data: new Uint8Array(memory.buffer, map.display(), mapSize * mapSize * 4)\r\n    });\r\n\r\n    let drawBackground = regl({\r\n        vert: background_vert,\r\n        frag: background_frag,\r\n        uniforms: {\r\n            color: regl.prop('color'),\r\n        },\r\n        depth: { enable: false },\r\n        attributes: {\r\n            position: [[-1, 4], [-1, -1], [4, -1]]\r\n        },\r\n        count: 3,\r\n    });\r\n\r\n    // Draw all map pixels\r\n    let drawMap = regl({\r\n        vert: map_vert,\r\n        frag: map_frag,\r\n        uniforms: {\r\n            time: ({tick}) => tick,\r\n            element_texture_dim: elementTextureDim,\r\n            element_texture: elementTexture,\r\n            map_size: mapSize,\r\n            map_texture: () => {\r\n                return mapTexture({\r\n                    width: mapSize,\r\n                    height: mapSize,\r\n                    data: new Uint8Array(memory.buffer, map.display(), mapSize * mapSize * 4) });\r\n            },\r\n        },\r\n        depth: { enable: false },\r\n        blend: {\r\n            enable: true,\r\n            func: {\r\n                srcRGB: 'src alpha',\r\n                srcAlpha: 'src alpha',\r\n                dstRGB: 'one minus src alpha',\r\n                dstAlpha: 'one minus src alpha',\r\n            },\r\n        },\r\n        attributes: {\r\n            position: [[-1, 4], [-1, -1], [4, -1]]\r\n        },\r\n        count: 3,\r\n    });\r\n\r\n    // Draw a single chunk\r\n    const drawChunk = regl({\r\n        vert: chunk_vert,\r\n        frag: chunk_frag,\r\n        attributes: {\r\n            position: [[-1, -1], [1, -1], [1, 1], [-1, 1]],\r\n        },\r\n        uniforms: {\r\n            color: [0.3, 0.7, 0.1, 1],\r\n            scale: regl.prop('scale'),\r\n            offset: regl.prop('offset'),\r\n        },\r\n        depth: { enable: false },\r\n        count: 4,\r\n        lineWidth: 1,\r\n        primitive: 'line loop'\r\n    });\r\n\r\n    // Load all map chunks\r\n    let chunks = (() => {\r\n        let chunks = [];\r\n\r\n        if (config.useChunks) {\r\n            let scale = config.chunkSize / mapSize;\r\n\r\n            for (let i = 0; i < map.chunks_count(); i++) {\r\n                let chunk = map.chunk(i);\r\n\r\n                chunks.push({\r\n                    scale: scale,\r\n                    offset: [-1 + scale + 2*(chunk.x()/config.size), 1 - scale - 2*(chunk.y()/config.size)],\r\n                });\r\n            }\r\n        }\r\n\r\n        return chunks;\r\n    })();\r\n\r\n    // Draw active chunks\r\n    const drawActiveChunks = () => {\r\n        if (config.useChunks && showActiveChunks) {\r\n            drawChunk(chunks.filter((_, index) => map.chunk(index).active_next_tick()));\r\n        }\r\n    }\r\n\r\n    const drawScene = () => {\r\n        regl.clear({\r\n            color: [0, 0, 0, 255],\r\n        })\r\n\r\n        drawBackground({color: backgroundColor});\r\n        drawMap();\r\n    }\r\n\r\n    const drawDebugInfo = () => {\r\n        drawActiveChunks();\r\n    }\r\n\r\n    return () => {\r\n        regl.poll();\r\n\r\n        drawScene();\r\n        drawDebugInfo();\r\n    };\r\n};\r\n\r\nexport { startWebGL};"],"sourceRoot":""}