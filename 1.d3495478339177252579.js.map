{"version":3,"sources":["webpack:///./render.js","webpack:///./ui.js","webpack:///./main.js","webpack:///../engine/pkg/engine_bg.js"],"names":["reglBuilder","require","canvas","document","getElementById","painting","lastPaint","repeat","addEventListener","event","preventDefault","clearInterval","window","setInterval","paint","body","startEvent","clientX","clientY","i","eventDistance","d","add","scale","norm","sub","Math","min","smoothPaint","boundingRect","getBoundingClientRect","scaleX","width","ceil","devicePixelRatio","scaleY","height","canvasLeft","left","canvasTop","top","x","floor","y","map","insert","Element","Sand","a","b","sqrt","pow","mag","magnitude","s","Map","regl","ptr_pixels","pixels","dataTexture","drawMap","Uint8Array","memory","buffer","texture","data","frag","vert","uniforms","attributes","position","count","poll","renderLoop","paused","tick","animationId","requestAnimationFrame","cachedTextDecoder","TextDecoder","module","ignoreBOM","fatal","decode","cachegetUint8Memory0","getStringFromWasm0","ptr","len","wasm","subarray","what","Object","freeze","Empty","Wall","this","element","obj","create","prototype","ret","__wrap","__wbg_random_eb1fab8e1db2d9d1","random","Error","__wbindgen_throw","arg0","arg1"],"mappings":"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","file":"1.d3495478339177252579.js","sourcesContent":["const reglBuilder = require(\"regl\");\r\nimport { memory } from \"./node_modules/engine/engine_bg\";\r\n\r\nlet startWebGL = ({ canvas, map }) => {\r\n    const regl = reglBuilder({\r\n        canvas\r\n    });\r\n\r\n    const width = map.width();\r\n    const height = map.height();\r\n    let ptr_pixels = map.pixels();\r\n    let pixels = new Uint8Array(memory.buffer, ptr_pixels, width * height * 4);\r\n    const dataTexture = regl.texture({ width, height, data: pixels });\r\n\r\n    let drawMap = regl({\r\n        frag: `\r\n        precision highp float;\r\n        uniform sampler2D data;\r\n        varying vec2 uv;\r\n        void main() {\r\n            vec2 textCoord = (uv * vec2(0.5, -0.5)) + vec2(0.5);\r\n            vec4 data = texture2D(data, textCoord);\r\n            int element = int((data.r * 255.) + 0.1);\r\n            vec4 color;\r\n            \r\n            // empty\r\n            if (element == 0) {\r\n                color = vec4(1, 1, 1, 1);\r\n            }\r\n            \r\n            if (element == 1) {\r\n                color = vec4(0, 0, 0, 1);\r\n            }\r\n            \r\n            // sand\r\n            if (element == 2) {\r\n                color = vec4(0.76, 0.7, 0.5, 1);\r\n            }\r\n            \r\n            gl_FragColor = color;\r\n        }`,\r\n\r\n        vert: `\r\n        precision mediump float;\r\n        attribute vec2 position;\r\n        varying vec2 uv;\r\n        void main() {\r\n            uv = position;\r\n            gl_Position = vec4(position, 0, 1);\r\n        }`,\r\n\r\n        uniforms: {\r\n            data: () => {\r\n                ptr_pixels = map.pixels();\r\n                pixels = new Uint8Array(memory.buffer, ptr_pixels, width * height * 4);\r\n\r\n                return dataTexture({width, height, data: pixels});\r\n            },\r\n        },\r\n\r\n        attributes: {\r\n            position: [[-1, 4], [-1, -1], [4, -1]]\r\n        },\r\n\r\n        count: 3,\r\n    });\r\n\r\n    return () => {\r\n        regl.poll();\r\n        drawMap();\r\n    };\r\n};\r\n\r\nexport { startWebGL};","import { width, height, map } from \"./main.js\";\r\nimport { Element } from \"./node_modules/engine/engine.js\";\r\n\r\nconst canvas = document.getElementById(\"canvas\");\r\n\r\nlet painting = false;\r\nlet lastPaint = null;\r\nlet repeat = null;\r\n\r\ncanvas.addEventListener(\"mousedown\", event => {\r\n    event.preventDefault();\r\n    painting = true;\r\n    clearInterval(repeat);\r\n    repeat = window.setInterval(() => paint(event), 100);\r\n    paint(event);\r\n    lastPaint = event;\r\n});\r\n\r\ndocument.body.addEventListener(\"mouseup\", event => {\r\n    clearInterval(repeat);\r\n    if (painting) {\r\n        event.preventDefault();\r\n        lastPaint = null;\r\n        painting = false;\r\n    }\r\n});\r\n\r\ncanvas.addEventListener(\"mousemove\", event => {\r\n    clearInterval(repeat);\r\n    smoothPaint(event);\r\n});\r\n\r\ncanvas.addEventListener(\"mouseleave\", event => {\r\n    clearInterval(repeat);\r\n    lastPaint = null;\r\n});\r\n\r\nconst paint = event => {\r\n    if (!painting) {\r\n        return;\r\n    }\r\n    const boundingRect = canvas.getBoundingClientRect();\r\n\r\n    const scaleX = canvas.width / Math.ceil(window.devicePixelRatio) / boundingRect.width;\r\n    const scaleY = canvas.height / Math.ceil(window.devicePixelRatio) / boundingRect.height;\r\n\r\n    const canvasLeft = (event.clientX - boundingRect.left) * scaleX;\r\n    const canvasTop = (event.clientY - boundingRect.top) * scaleY;\r\n\r\n    const x = Math.min(Math.floor(canvasLeft), width - 1);\r\n    const y = Math.min(Math.floor(canvasTop), height - 1);\r\n\r\n    map.insert(\r\n        x,\r\n        y,\r\n        Element.Sand\r\n    );\r\n};\r\n\r\nfunction smoothPaint(event) {\r\n    clearInterval(repeat);\r\n    repeat = window.setInterval(() => paint(event), 100);\r\n\r\n    let startEvent = { clientX: event.clientX, clientY: event.clientY };\r\n\r\n    if (!painting) {\r\n        return;\r\n    }\r\n\r\n    let i = 0;\r\n    paint(startEvent);\r\n\r\n    if (lastPaint) {\r\n        while (eventDistance(startEvent, lastPaint) > 1 / 3) {\r\n            let d = eventDistance(startEvent, lastPaint);\r\n            startEvent = add(\r\n                startEvent,\r\n                scale(norm(sub(lastPaint, event)), Math.min(1 / 3, d))\r\n            );\r\n            i++;\r\n            if (i > 1000) {\r\n                break;\r\n            }\r\n            paint(startEvent);\r\n        }\r\n    }\r\n    lastPaint = event;\r\n}\r\n\r\nconst eventDistance = (a, b) => {\r\n    return Math.sqrt(\r\n        Math.pow(a.clientX - b.clientX, 2) + Math.pow(a.clientY - b.clientY, 2),\r\n        2\r\n    );\r\n};\r\n\r\nconst add = (a, b) => {\r\n    return { clientX: a.clientX + b.clientX, clientY: a.clientY + b.clientY };\r\n};\r\n\r\nconst sub = (a, b) => {\r\n    return { clientX: a.clientX - b.clientX, clientY: a.clientY - b.clientY };\r\n};\r\n\r\nconst norm = a => {\r\n    let mag = magnitude(a);\r\n    return { clientX: a.clientX / mag, clientY: a.clientY / mag };\r\n};\r\n\r\nconst scale = (a, s) => {\r\n    return { clientX: a.clientX * s, clientY: a.clientY * s };\r\n};\r\n\r\nconst magnitude = a => {\r\n    return Math.sqrt(Math.pow(a.clientX, 2) + Math.pow(a.clientY, 2), 2);\r\n};","import { Map } from \"./node_modules/engine/engine.js\";\r\nimport { startWebGL } from \"./render\";\r\nimport {} from \"./ui\";\r\n\r\nlet width = 100;\r\nlet height = 100;\r\nconst map = Map.new(width, height);\r\n\r\nconst canvas = document.getElementById(\"canvas\");\r\n\r\ncanvas.width = width * Math.ceil(window.devicePixelRatio);\r\ncanvas.height = height * Math.ceil(window.devicePixelRatio);\r\n\r\nlet drawMap = startWebGL({ canvas, map });\r\n\r\nconst renderLoop = () => {\r\n    if (!window.paused) {\r\n        map.tick();\r\n    }\r\n\r\n    drawMap();\r\n    window.animationId = requestAnimationFrame(renderLoop);\r\n};\r\n\r\nrenderLoop();\r\n\r\nexport { canvas, width, height, map };","import * as wasm from './engine_bg.wasm';\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction notDefined(what) { return () => { throw new Error(`${what} is not defined`); }; }\n/**\n* Represent an element of a pixel\n*/\nexport const Element = Object.freeze({ Empty:0,\"0\":\"Empty\",Wall:1,\"1\":\"Wall\",Sand:2,\"2\":\"Sand\", });\n/**\n* Represents a map of given width and height composed of pixels\n*/\nexport class Map {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Map.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_map_free(ptr);\n    }\n    /**\n    * Creates a new empty map with given width and height\n    * @param {number} width\n    * @param {number} height\n    * @returns {Map}\n    */\n    static new(width, height) {\n        var ret = wasm.map_new(width, height);\n        return Map.__wrap(ret);\n    }\n    /**\n    * Inserts a new pixel of given element at x,y\n    * @param {number} x\n    * @param {number} y\n    * @param {number} element\n    */\n    insert(x, y, element) {\n        wasm.map_insert(this.ptr, x, y, element);\n    }\n    /**\n    * Clears the map so its empty\n    */\n    clear() {\n        wasm.map_clear(this.ptr);\n    }\n    /**\n    * Simulates a tick and process all pixels\n    */\n    tick() {\n        wasm.map_tick(this.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    width() {\n        var ret = wasm.map_width(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    height() {\n        var ret = wasm.map_height(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    pixels() {\n        var ret = wasm.map_pixels(this.ptr);\n        return ret;\n    }\n}\n/**\n* Represents a read-only pixel on the map\n*/\nexport class Pixel {\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_pixel_free(ptr);\n    }\n}\n\nexport const __wbg_random_eb1fab8e1db2d9d1 = typeof Math.random == 'function' ? Math.random : notDefined('Math.random');\n\nexport const __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n"],"sourceRoot":""}